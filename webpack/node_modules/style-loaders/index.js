const url = require('url');
const is = require('is');
const qs = require('querystring');
const ExtractTextPlugin = require('extract-text-webpack-plugin');

exports.toQuery = (...args) => {
	return !is.empty(args[0]) ? qs.unescape(qs.stringify(...args)) : null;
};

exports.toQueryParams = (...args) => {
	return !is.empty(args[0]) ? `?${exports.toQuery(...args)}` : '';
};

exports.fromQuery = (...args) => {
	return is.string(args[0]) ? qs.parse(...args) : null;
};

exports.sourceLoader = (name, options = {}) => {
	const parts = url.parse(name);
	const loader = `${parts.pathname}-loader`;
	const query = Object.assign({}, options, exports.fromQuery(parts.query));
	return loader + exports.toQueryParams(query);
};

exports.generateLoader = (name, options = {}) => {
	const parts = url.parse(name);
	const scss = parts.pathname === 'sass' && !/\bindentedSyntax\b/i.test(parts.query) && 'scss';
	const query = Object(options[scss || parts.pathname]);
	return exports.sourceLoader(name, Object.assign({ sourceMap }, query));
};

exports.generateLoaders = (tasks, options = {}) => {
	const sourceMap = options.sourceMap;
	const fallback = options.fallback;
	const source = is.array(tasks) ? tasks : is.string(tasks) ? [tasks] : [];
	const loader = source.map((taskName) => exports.generateLoader(taskName, options));
	if (options.extract) {
		return ExtractTextPlugin.extract({ fallback: fallback, use: loader });
	}
	return fallback ? [fallback].concat(loader) : loader;
};

exports.cssLoaders = (options) => {
	return {
		css: exports.generateLoaders('css', options),
		postcss: exports.generateLoaders('css', options),
		less: exports.generateLoaders(['css', 'less'], options),
		sass: exports.generateLoaders(['css', 'sass?indentedSyntax'], options),
		scss: exports.generateLoaders(['css', 'sass'], options),
		stylus: exports.generateLoaders(['css', 'stylus'], options),
		styl: exports.generateLoaders(['css', 'stylus'], options),
	};
};

exports.styleLoaders = (options) => {
	const loaders = exports.cssLoaders(options);
	return Object.keys(loaders).map(extension => {
		return {
			test: new RegExp(`\\.${extension}$`),
			use: loaders[extension],
		};
	});
};
